<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rabear&#39;s</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.rabears.com/"/>
  <updated>2017-12-27T06:10:15.321Z</updated>
  <id>https://blog.rabears.com/</id>
  
  <author>
    <name>Jaden Zhuang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Scala函数式编程》</title>
    <link href="https://blog.rabears.com/2017/12/27/fp-in-scala/"/>
    <id>https://blog.rabears.com/2017/12/27/fp-in-scala/</id>
    <published>2017-12-27T06:00:03.000Z</published>
    <updated>2017-12-27T06:10:15.321Z</updated>
    
    <content type="html"><![CDATA[<p>若从学院派的角度来讲，此书对于讲解函数式，或可称为异端，因为它没有冗长晦涩的理论讲解与分析；若从学习Scala的角度来看，或可视作另类，因为它通篇没有介绍Scala的语法。这是否意味着她两边都不讨好呢？——非也！这实际得看读者的水平和期望。</p><p>我不愿意盲目推荐，免得误人子弟。要阅读此书，必得具备以下两个条件。其一是具备一定的Scala知识，尤其是高阶函数，模式匹配以及尾递归的知识。其二是对函数式编程满怀着渴望，并且不拒绝大量的编码练习。</p><p>阅读之前，先扪心自问。若不具备这两个条件，奉劝读者诸君远离此书，免得浪费你的时间。</p><img src="/2017/12/27/fp-in-scala/fpinscala.png" alt="fpinscala.png" title=""><p>好了，通过这一关，我得努力给您推销此书的好了。</p><p>我其实深深折服于本书第一章向我们打开的函数式世界。原来，代码可以这样写。好像口念咒语一般，神奇的魔法打开了异度空间，那里充满了绚烂、无穷以及未知。其实，这个空间无处不在，只是我们沉迷于面向对象的世界，成为了哥白尼之前的世人，以为面向对象就是程序员的全部世界。</p><p>这一章的案例可以让我们极度快速的明白函数的真谛，以及函数式编程带来的益处。</p><p>虽然是实践类的书籍，但它与Martin Odersky的Programming in Scala不同，它或者通过正文或者通过Sidebar或者通过注释，时时刻刻向读者传达函数式世界的专有术语。例如书中提到的pure function、referential transparency(RT)、subsitution model、monads、strictness等概念。这使得对函数式编程并不了解的读者，可以通过阅读本身，扩充自己的知识库，进而成为交流的基础。显然，这比单纯了解某种语言的语法有用许多。</p><p>本书的一个特殊之处在于她选择了Scala库中的一些设计元素作为案例，并以纯函数的方式重新实现，例如实现了自己的List、Option、Either、Stream等。这种方式有些取巧，实则恰如其分的找到了一个切入点。因为读者熟悉Scala，故而对这些例子并不陌生，这就降低了学习的难度；同时，它又极其符合函数式编程的特征，且能够基于这些设计元素传达函数式思想；额外的奖励更是让读者更加深入地掌握了Scala的语法本质；真可谓一举三得啊！</p><p>然而，我不得不提醒读者。若要阅读此书，需得完成本书的练习方有收获。这些练习就是作者设置的拦路虎，它让我们的阅读变得举步维艰。坦白说，时至今日，我还在慢慢地阅读本书的第五章呢。真是“路漫漫其修远兮，吾将上下而求索”啊！但我能清晰地感觉到自己的变化。就在阅读完第三章Functional Data Structures后，我感觉自己对模式匹配、泛型、高阶函数有了更深入地理解，也能够非常自如地运用map、flatMap、filter等操作，对List也有了更深入的理解。</p><p>虽然阅读并不顺畅，但只要你能看到自己的一点点进步，我想一定会有热情推动着你继续阅读，即使需要排除艰险。读书未必快乐，然而耽于安逸亦未必赐予你幸福；至少我相信，知识的汲取总会给你回报，这份回报又岂止是快乐那么简单！</p><hr><p>阅读建议I<br><blockquote><p>要练习本书案例，没有必要使用专业的IDE。然而，Scala提供的交互式窗口又不太适合我们输入代码。当然，我们也可以使用诸如Sublime编写代码，再到交互式窗口中以:l命令加载代码文件。可这种交互并不方便。所以，建议大家下载由上海广谈信息技术有限公司开发的开源软件ScalaConsole，它非常适合用来尝试scala语言特性、标准库及第三方库的api使用方法。</p></blockquote><br>阅读建议II<br><blockquote><p>本书练习一定要做，虽然某些练习有些难。大家或许会想，即使做了，我该怎么知道解题是否正确，又或者是否有更好的方案？所幸，本书作者在其github上给出了全书所有练习的答案，你可以下载它们，作为参考。不过你得忍住诱惑，只有在通过了充分思考，确定解题有难度时，才能阅读答案，否则就弱化练习的好处了。</p></blockquote></p><p>本文转载自 <a href="http://zhangyi.farbox.com/post/afterreading/fp-in-scala" target="_blank" rel="external">逸言</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;若从学院派的角度来讲，此书对于讲解函数式，或可称为异端，因为它没有冗长晦涩的理论讲解与分析；若从学习Scala的角度来看，或可视作另类，因为它通篇没有介绍Scala的语法。这是否意味着她两边都不讨好呢？——非也！这实际得看读者的水平和期望。&lt;/p&gt;
&lt;p&gt;我不愿意盲目推荐，
      
    
    </summary>
    
      <category term="Translation" scheme="https://blog.rabears.com/categories/Translation/"/>
    
      <category term="Scala" scheme="https://blog.rabears.com/categories/Translation/Scala/"/>
    
    
      <category term="Scala" scheme="https://blog.rabears.com/tags/Scala/"/>
    
      <category term="FP" scheme="https://blog.rabears.com/tags/FP/"/>
    
  </entry>
  
  <entry>
    <title>目击死亡</title>
    <link href="https://blog.rabears.com/2017/12/05/witness-death/"/>
    <id>https://blog.rabears.com/2017/12/05/witness-death/</id>
    <published>2017-12-05T06:16:39.000Z</published>
    <updated>2017-12-27T06:45:06.148Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>死亡绝不是一瞬间的事，而是漫长痛苦的过程， 从一出生就开始死去<br>对于死亡的恐惧来自于被遗忘， 人生已然渺小， 而死亡将抹去你活过的痕迹</p></blockquote><a id="more"></a><p>我有一段特殊的记忆，在我小的时候，我曾经看到过自己死亡的样子</p><p>那个我就躺在茂密的草丛里，穿着蓝色的运动服</p><p>而现实中的我丢失了那套蓝色运动服</p><p>那套蓝色运动服如今依然好好的保存在相册里</p><p>不敢再次去那里确认自己的尸体</p><p>会不会我才是代替者,代替了本体的虚假存在？</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;死亡绝不是一瞬间的事，而是漫长痛苦的过程， 从一出生就开始死去&lt;br&gt;对于死亡的恐惧来自于被遗忘， 人生已然渺小， 而死亡将抹去你活过的痕迹&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Caprices" scheme="https://blog.rabears.com/categories/Caprices/"/>
    
    
  </entry>
  
  <entry>
    <title>论工业社会及其未来</title>
    <link href="https://blog.rabears.com/2017/11/01/unabomber/"/>
    <id>https://blog.rabears.com/2017/11/01/unabomber/</id>
    <published>2017-11-01T09:03:11.000Z</published>
    <updated>2017-11-02T06:54:48.871Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;pullquote&quot;&gt;&lt;p&gt;技术完全控制地球上的一切，人类自由基本上将不复存在，因为个人无法对抗用超级技术武装起来的大型组织&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;来自Unabomber的警示现如今正在一一被验证，正如《人类简史》中提到的技术进步反而制约人类的自由，而人类社会熵的不断扩大也正在给自己埋下了一颗定时炸弹&lt;br&gt;
    
    </summary>
    
      <category term="Caprices" scheme="https://blog.rabears.com/categories/Caprices/"/>
    
    
      <category term="Unabomber" scheme="https://blog.rabears.com/tags/Unabomber/"/>
    
      <category term="大学炸弹客" scheme="https://blog.rabears.com/tags/%E5%A4%A7%E5%AD%A6%E7%82%B8%E5%BC%B9%E5%AE%A2/"/>
    
      <category term="论工业社会及其未来" scheme="https://blog.rabears.com/tags/%E8%AE%BA%E5%B7%A5%E4%B8%9A%E7%A4%BE%E4%BC%9A%E5%8F%8A%E5%85%B6%E6%9C%AA%E6%9D%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java 9 – The Ultimate Feature List</title>
    <link href="https://blog.rabears.com/2017/09/27/java-9-new-feature/"/>
    <id>https://blog.rabears.com/2017/09/27/java-9-new-feature/</id>
    <published>2017-09-27T11:42:01.000Z</published>
    <updated>2017-10-26T07:11:57.597Z</updated>
    
    <content type="html"><![CDATA[<blockquote><footer><strong>Java 9 的发布在历经多次跳票之后，终于正式发布。从这个版本开始，Java 将每半年发布一个版本。 本文翻译自Java 9 Ultimate Feature List, 让我们看看这次发布我们将拥有哪些高级特性。</strong><cite><a href="http://openjdk.java.net/projects/jdk9/" target="_blank" rel="external">openjdk.java.net</a></cite></footer></blockquote><a id="more"></a><p><a href="http://384uqqh5pka2ma24ild282mv.wpengine.netdna-cdn.com/wp-content/uploads/2014/09/Java-9-Telescope.png" target="_blank" rel="external"><img src="http://384uqqh5pka2ma24ild282mv.wpengine.netdna-cdn.com/wp-content/uploads/2014/09/Java-9-Telescope.png" alt="Java 9 Telescope"></a></p><p><strong>This post will be updated with new features targeted at the upcoming Java 9 release</strong> </p><p>The OpenJDK development is picking up speed: after the Java 8 launch in March 2014, we’re expecting to enter a 2 year release cycle. Java 9 will reportedly be released in 2016, and the JEPs (JDK Enhancement Proposals) that target the release keep getting published. Moreover, some JSRs (Java Specification Requests) are already being worked on and we’ve also added a hint of other features that might be included.</p><p>The flagship features are the Jigsaw project, significant performance improvements and long awaited APIs including: Process API updates, JSON as part of java.util and a money handling API. For those of you who want to be on the bleeding edge, JDK 9 early access builds are already available <a href="https://jdk9.java.net/" target="_blank" rel="external">here</a>.</p><p>In this post we’ll keep updating around the main new features for Java 9 and what they’re all about. So stay tuned for additional updates!</p><h2 id="Table-of-contents"><a href="#Table-of-contents" class="headerlink" title="Table of contents"></a>Table of contents</h2><p><span style="color: #339966;"><span style="color: #000000;">1.</span> [Accepted]</span> <a href="#jigsaw">Project Jigsaw – Modular Source Code</a><br><span style="color: #339966;"><span style="color: #000000;">2.</span> [Accepted]</span> <a href="#processapi">Process API Updates</a><br><span style="color: #339966;"><span style="color: #000000;">3.</span> [Accepted]</span> <a href="#jsonapi">Light Weight JSON API</a><br><span style="color: #339966;"><span style="color: #000000;">4.</span> [Accepted]</span> <a href="#moneyapi">Money and Currency API</a><br><span style="color: #339966;"><span style="color: #000000;">5.</span> [Accepted]</span> <a href="#locking">Improved Contended Locking</a><br><span style="color: #339966;"><span style="color: #000000;">6.</span> [Accepted] </span><a href="#codecache">Segmented Code Cache</a><br><span style="color: #339966;"><span style="color: #000000;">7.</span> [Accepted] </span><a href="#sjavac">Smart Java Compilation – Phase Two</a><br><span style="color: #339966;"><span style="color: #ff9900;"><span style="color: #000000;">8.</span> [Expected]</span> </span><a href="#http2">HTTP 2 Client</a><br><span style="color: #ff9900;"><span style="color: #000000;">9.</span> [</span><span style="color: #ff9900;">Expected</span><span style="color: #ff9900;">] </span><a href="#repl">REPL in Java</a></p><h3 id="Update-20-11-2014"><a href="#Update-20-11-2014" class="headerlink" title="Update 20/11/2014:"></a>Update 20/11/2014:</h3><p><span style="color: #339966;"><span style="color: #000000;">10.</span> [Accepted]</span> <a href="#unifiedlogging">Unified JVM Logging</a><br><span style="color: #339966;"><span style="color: #000000;">11.</span> [Accepted]</span> <a href="#compilercontrol">Compiler Control</a><br><span style="color: #339966;"><span style="color: #000000;">12.</span> [Accepted]</span> <a href="#dtls">Datagram Transport Layer Security (DTLS)</a><br><span style="color: #339966;"><span style="color: #000000;">13.</span> [Accepted]</span> <a href="#javadoc">HTML5 Javadoc</a></p><h3 id="Additional-fixes-cleanup"><a href="#Additional-fixes-cleanup" class="headerlink" title="Additional fixes / cleanup:"></a>Additional fixes / cleanup:</h3><p><span style="color: #339966;"><span style="color: #000000;">14.</span> [Accepted]</span> <a href="#elideimport">Elide Deprecation Warnings on Import Statements</a><br><span style="color: #339966;"><span style="color: #000000;">15.</span> [Accepted]</span> <a href="#doclint">Resolve Lint and Doclint Warnings</a><br><span style="color: #339966;"><span style="color: #000000;">16.</span> [Accepted]</span> <a href="#millingcoin">Milling Project Coin</a><br><span style="color: #339966;"><span style="color: #000000;">17.</span> [Accepted]</span> <a href="#removegc">Remove GC Combinations Deprecated in JDK 8</a><br><span style="color: #339966;"><span style="color: #000000;">18.</span> [Accepted]</span> <a href="#processimport">Process Import Statements Correctly</a><br><span style="color: #000000;">19.</span> <a href="#newfeatures">Where do new features come from?</a></p><h2 id="Accepted-features"><a href="#Accepted-features" class="headerlink" title="Accepted features"></a>Accepted features</h2><p><a name="jigsaw"></a></p><h3 id="1-Project-Jigsaw-–-Modular-Source-Code"><a href="#1-Project-Jigsaw-–-Modular-Source-Code" class="headerlink" title="1. Project Jigsaw – Modular Source Code"></a>1. Project Jigsaw – Modular Source Code</h3><p><a href="http://openjdk.java.net/projects/jigsaw/" title="Project Jigsaw" target="_blank" rel="external">Project Jigsaw</a>’s goal is to make Java modular and break the <a href="http://www.oracle.com/technetwork/java/javase/tech/index.html" target="_blank" rel="external">JRE</a> to interoperable components, one of the most hyped features for Java 9. This JEP is the first out of <a href="http://mail.openjdk.java.net/pipermail/jigsaw-dev/2014-July/003417.html" target="_blank" rel="external">4 steps</a> towards Jigsaw and will not change the actual structure of the JRE and JDK. The purpose of this step is to reorganize the JDK source code into modules, enhance the build system to compile modules, and enforce module boundaries at build time. The project was originally intended for Java 8 but was delayed since and retargeted at Java 9.<br>Jigsaw项目是为了模块化Java代码、将JRE分成可相互协作的组件，这也是Java 9 众多特色种的一个。JEP是迈向Jigsaw四步中的第一步，它不会改变JRE和JDK的真实结构。JEP是为了模块化JDK源代码，让编译系统能够模块编译并在构建时检查模块边界。这个项目原本是随Java 8发布的，但由于推迟，所以将把它加到Java 9.</p><p>Once it’s finished, it would allow creating a scaled down runtime Jar (rt.jar) customised to the components a project actually needs. The JDK 7 and JDK 8 rt.jar’s have about 20,000 classes that are part of the JDK even if many of them aren’t really being used in a specific envrionment (although a partial solution is included in the Java 8 <a href="http://www.oracle.com/technetwork/java/embedded/resources/tech/compact-profiles-overview-2157132.html" title="Java 8 Compact Features" target="_blank" rel="external">compact profiles</a> feature). The motivation behind this is to make Java easily scalable to small computing devices (Internet of Things), improve security and performance, and make it easier for developers to construct and maintain libraries.<br>一旦它完成，它可能允许根据一个项目需求自定义组件从而减少rt.jar的大小。在JDK 7 和JDK 8的rt.jar包中有大约20,000个类，但有很多类在一些特定的环境里面并没有被用到(即使在Java 8的紧凑分布特性中已经包含了一部分解决方法也存在着类冗余)。这么做是为了能让Java能够容易应用到小型计算设备(比如网络设备)中，提高它的安全和性能，同时也能让开发者更容易构建和维护这些类库。</p><p><a href="http://openjdk.java.net/jeps/201" title="JEP 201" target="_blank" rel="external">More about JEP 201</a></p><p><a name="processapi"></a></p><h3 id="2-Process-API-Updates"><a href="#2-Process-API-Updates" class="headerlink" title="2. Process API Updates"></a>2. Process API Updates</h3><p>So far there has been a limited ability for controlling and managing operating system processes with Java. For example, in order to do something as simple as get your process PID today, you would need to either access native code or use some sort of a workaround. More than that, it would require a different implementation for each platform to guarantee you’re getting the right result.<br>截止到目前，Java控制与管理系统进程的能力是有限的。举个例子，现在为了简便获取你程序的进程PID，你要么调用本地程序要么要自己使用一些变通方案。更多的是，每个（系统）平台需要有一个不同实现来确保你能获得正确的结果。<br>In Java 9, expect the code for retrieving Linux PIDs, that now looks like this:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    Process proc = Runtime.getRuntime().exec(<span class="keyword">new</span> String[]&#123; <span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo $PPID"</span> &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (proc.waitFor() == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        InputStream in = proc.getInputStream();</div><div class="line">        <span class="keyword">int</span> available = in.available();</div><div class="line">        <span class="keyword">byte</span>[] outputBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[available];</div><div class="line"></div><div class="line">    in.read(outputBytes);</div><div class="line">    String pid = <span class="keyword">new</span> String(outputBytes);</div><div class="line"></div><div class="line">    System.out.println(<span class="string">"Your pid is "</span> + pid);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    </div></pre></td></tr></table></figure><p>To turn into something like this (that also supports all operating systems):<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(<span class="string">"Your pid is "</span> + Process.getCurrentPid());</div><div class="line"> </div></pre></td></tr></table></figure></p><p>The update will extend Java’s ability to to interact with the operating system: New direct methods to handle PIDs, process names and states, and ability to enumerate JVMs and processes and more.<br>这次更新将会扩展Java与操作系统的交互能力：新增一些新的直接明了的方法去处理PIDs，进程名字和状态以及枚举多个JVM和进程以及更多事情。</p><p><a href="http://openjdk.java.net/jeps/102" title="JEP 102" target="_blank" rel="external">More about JEP 102</a><br><a name="jsonapi"></a></p><h3 id="3-Light-Weight-JSON-API"><a href="#3-Light-Weight-JSON-API" class="headerlink" title="3. Light-Weight JSON API"></a>3. Light-Weight JSON API</h3><p>Currently there are alternatives available for handling JSON in Java, what’s unique about this API is that it would be part of the language, lightweight and would use the new capabilities of Java 8. And will be delivered right through java.util (Unlike <a href="https://jsonp.java.net/" title="JSONP" target="_blank" rel="external">JSR 353</a> which uses an external package or other <a href="https://code.google.com/p/google-gson/" title="google-gson" target="_blank" rel="external">alternatives</a>).</p><p>目前有多种处理JSON的Java工具，但JSON API 独到之处在于JSON API将作为Java语言的一部分，轻量并且运用Java 8的新特性。它将放在java.util包里一起发布(但在JSR 353里面的JSON是用第三方包或者其他的方法处理的).<br>** Code samples coming soon!</p><p><a href="http://openjdk.java.net/jeps/198" title="JEP 198" target="_blank" rel="external">More about JEP 198</a><br><a name="moneyapi"></a></p><h3 id="4-Money-and-Currency-API"><a href="#4-Money-and-Currency-API" class="headerlink" title="4. Money and Currency API"></a>4. Money and Currency API</h3><p>After the new <a href="http://blog.takipi.com/5-features-in-java-8-that-will-change-how-you-code/#datetime" title="Date and Time API" target="_blank" rel="external">Date and Time API</a> introduced in Java 8, Java 9 brings with it a new and official API for representing, transporting, and performing comprehensive calculations with Money and Currency. To find out more about the project, you can visit JavaMoney on Github. Code and usage examples are already available right here . Here are a few highlights:<br>在Java 8引进了日期和时间的API之后, Java 9引入了新的货币API, 用以表示货币, 支持币种之间的转换和各种复杂运算. 关于这个项目的具体情况, 请访问<a href="https://github.com/JavaMoney,里面已经给出了使用说明和示例" target="_blank" rel="external">https://github.com/JavaMoney,里面已经给出了使用说明和示例</a>, 以下是几个重要的例子:<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Money amt1 = Money.of(<span class="number">10.1234556123456789</span>, <span class="string">"USD"</span>); <span class="comment">// Money is a BigDecimal</span></div><div class="line">FastMoney amt2 = FastMoney.of(<span class="number">123456789</span>, <span class="string">"USD"</span>); <span class="comment">// FastMoney is up to 5 decimal places</span></div><div class="line">Money total = amt1.add(amt2);      </div><div class="line">   </div></pre></td></tr></table></figure></p><p><em>The new money types: Money &amp; FastMoney</em></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MonetaryAmountFormat germanFormat = MonetaryFormats.getAmountFormat( Locale.GERMANY);</div><div class="line">System.out.println(germanFormat.format(monetaryAmount)); <span class="comment">// 1.202,12 USD</span></div><div class="line">   </div></pre></td></tr></table></figure><p><em>Formatting money according to different countries</em></p><p><a href="https://jcp.org/en/jsr/detail?id=354" title="JSR 354" target="_blank" rel="external">More about JSR 354</a><br><a name="locking"></a></p><h3 id="5-Improve-Contended-Locking"><a href="#5-Improve-Contended-Locking" class="headerlink" title="5. Improve Contended Locking"></a>5. Improve Contended Locking</h3><p>Lock contention is a performance bottleneck for many multithreaded Java applications. The enhancement proposal looks into improving the performance of Java object monitors as measured by different benchmarks. One of the these tests is <a href="http://www.volano.com/benchmarks.html" title="Volano" target="_blank" rel="external">Volano</a>. It simulates a chat server with huge thread counts and client connections, many of them trying to access the same resources and simulate a heavy duty real world application.</p><p>These kind of stress tests push JVMs to the limit and try to determine the maximum throughput they can achieve, usually in terms of messages per second. The ambitious success metric for this JEP is a significant improvement over 22 different benchmarks. If the effort will succeed, these performance improvements will be rolling out in Java 9.</p><p>锁争用是限制许多Java多线程应用性能的瓶颈. 新的机制在改善Java对象监视器的性能方面已经得到了多种基准(benchmark)的验证, 其中包括Volano. 测试中通讯服务器开放了海量的进程来连接客户端, 其中有很多连接都申请同一个资源, 以此模拟重负荷日常应用.</p><p>通过诸如此类的压力测试我们可以估算JVM的极限吞吐量(每秒的消息数量). JEP在22种不同的测试中都得到了出色的成绩, 新的机制如果能在Java 9中得到应用的话, 应用程序的性能将会大大提升.<br><a href="http://openjdk.java.net/jeps/143" title="JEP 143" target="_blank" rel="external">More about JEP 143</a><br><a name="codecache"></a></p><h3 id="6-Segmented-Code-Cache"><a href="#6-Segmented-Code-Cache" class="headerlink" title="6. Segmented Code Cache"></a>6. Segmented Code Cache</h3><p>Another performance improvement for Java 9 is coming from the JIT compiler angle. When certain areas of code are executed rapidly, the VM compiles them to native code and stores them in the code cache. This update looks into segmenting the code cache to different areas of compiled code in order to improve the compiler’s performance.</p><p>Instead of a single area, the code cache will be segmented into 3 by the code’s lifetime in the cache:<br>– Code that will stay in the cache forever (JVM internal / non-method code)<br>– Short lifetime (Profiled code, specific to a certain set of conditions)<br>– Potentially long lifetime (Non-profiled code)<br>The segmentation would allow for several performance improvements to happen. For example, the method sweeper would be able to skip non-method code and act faster.</p><p>Java 9的另一个性能提升来自于JIT(Just-in-time)编译器. 当某段代码被大量重复执行的时候, 虚拟机会把这段代码编译成机器码(native code)并储存在代码缓存里面, 进而通过访问缓存中不同分段的代码来提升编译器的效率.</p><p>和原来的单一缓存区域不同的是, 新的代码缓存根据代码自身的生命周期而分为三种:</p><ul><li>永驻代码(JVM 内置 / 非方法代码)</li><li>短期代码(仅在某些条件下适用的配置性(profiled)代码)</li><li>长期代码(非配置性代码)</li></ul><p>缓存分段会在各个方面提升程序的性能, 比如做垃圾回收扫描的时候可以直接跳过非方法代码(永驻代码), 从而提升效率.</p><p><a href="http://openjdk.java.net/jeps/197" title="JEP 197" target="_blank" rel="external">More about JEP 197</a><br><a name="sjavac"></a></p><h3 id="7-Smart-Java-Compilation-Phase-Two"><a href="#7-Smart-Java-Compilation-Phase-Two" class="headerlink" title="7. Smart Java Compilation, Phase Two"></a>7. Smart Java Compilation, Phase Two</h3><p>The Smart Java Compilation tool, or sjavac, was first worked on around <a href="http://openjdk.java.net/jeps/139" title="JEP 139" target="_blank" rel="external">JEP 139</a> in order to improve JDK build speeds by having the javac compiler run on all cores. With JEP 199, it enters Phase Two, where it will be improved and generalized so that it can be used by default and build other projects than the JDK.</p><p>智能Java编译工具sjavac的第一阶段开始于JEP 139这个项目, 用于在多核处理器上提升JDK的编译速度. 现在这个项目已经进入第二阶段(JEP 199), 目的是改进sjavac并让其成为取代目前JDK编译工具javac的Java默认的通用编译工具.<br><a href="http://openjdk.java.net/jeps/199" title="JEP 199" target="_blank" rel="external">More about JEP 199</a></p><h2 id="What-else-to-expect"><a href="#What-else-to-expect" class="headerlink" title="What else to expect?"></a>What else to expect?</h2><p><a name="http2"></a></p><h3 id="8-HTTP-2-Client"><a href="#8-HTTP-2-Client" class="headerlink" title="8. HTTP 2 Client"></a>8. HTTP 2 Client</h3><p>HTTP 2.0 hasn’t been released yet as a standard but it will be submitted for final review soon and it’s expected to be finalized before the release of Java 9. JEP 110 will define and implement a new HTTP client for Java that will replace HttpURLConnection, and also implement HTTP 2.0 and websockets. It wasn’t published as an accepted JEP yet but its targeting Java 9 and we expect it to be included.</p><p>The official HTTP 2.0 RFC release date is currently set to February 2015, building on top of Google’s SPDY algorithm. SPDY has already shown great speed improvements over HTTP 1.1 ranging between 11.81% to 47.7% and its implementation already exists in most modern browsers.</p><p>HTTP 2.0标准虽然还没正式发布, 但是已经进入了最终审查阶段, 预计可以在Java 9发布之前审查完毕. JEP 110将会重新定义并实现一个全新的Java HTTP客户端, 用来取代现在的HttpURLConnection, 同时也会实现HTTP 2.0和网络接口(原文websockets). 它现在还没被JEP正式认可但我们希望在Java 9中包含这一项目的内容.</p><p>官方的HTTP 2.0 RFC(Request for Comments, 官方技术讨论/会议记录等等的一系列文档记录)预订于2015年2月发布, 它是基于Google发布的SPDY(Speedy, 快速的)协议. 基于SPDY协议的网络相对于基于HTTP 1.1协议的网络有11.81%到47.7%之间的显著提速, 现在已经有浏览器实现了这个协议.<br><a href="http://openjdk.java.net/jeps/110" title="JEP 110" target="_blank" rel="external">More about JEP 110</a><br><a name="repl"></a></p><h3 id="9-Project-Kulla-–-REPL-in-Java"><a href="#9-Project-Kulla-–-REPL-in-Java" class="headerlink" title="9. Project Kulla – REPL in Java"></a>9. Project Kulla – REPL in Java</h3><p>Recently announced, a bit unlikely to hit Java 9 but might make it on time with a targeted integration date set in April 2015. Today there’s no “native” Java way to REPL (Read-Eval-Print-Loop). Meaning, if you want to run a few lines of Java to check out them quickly on their own you will have to wrap it all in a separate project or method. There are REPL add-ons to popular IDEs and some other solutions like Java REPL, but no official way to do this so far – Project Kulla might be the answer.</p><p>这个取名为Kulla的项目最近宣布将于2015年4月整合测试, 虽然已经不太有希望能赶上Java 9的发布, 但如果进度快的话或许刚好能赶上. 现在Java并没有来自官方的REPL(Read-Eval-Print-Loop)方式, 也就是说现在如果你想要跑几行Java代码做一个快速的测试, 你仍然需要把这几行代码封装在项目或者方法里面. 虽然在一些流行的IDE里面有Java REPL工具, 但它们并没有官方支持, 而Kulla项目或许就能成为Java官方发布的REPL解决方案.<br><a href="http://mail.openjdk.java.net/pipermail/announce/2014-August/000181.html" title="Project Kulla" target="_blank" rel="external">More about Project Kulla</a></p><p><a name="unifiedlogging"></a></p><h3 id="10-Unified-JVM-Logging"><a href="#10-Unified-JVM-Logging" class="headerlink" title="10. Unified JVM Logging"></a>10. Unified JVM Logging</h3><p>Today it’s hard to make sense of the root cause for performance issues and crashes of the JVM. One way to tackle this is introducing one single system for all JVM components that would allow fine-grained, and easy-to-configure JVM logging. Currently, different components of the JVM use different mechanisms and conventions for logging, making it harder to debug.</p><p><a href="http://openjdk.java.net/jeps/158" target="_blank" rel="external">More about JEP 158</a><br><a name="compilercontrol"></a></p><h3 id="11-Compiler-Control"><a href="#11-Compiler-Control" class="headerlink" title="11. Compiler Control"></a>11. Compiler Control</h3><p>Taking on the HotSpot JVM and extending the controls for compiler options down to the method level. After this update, the JIT compiler options could be modified even during runtime depending on the specific method that’s being compiled.</p><p><a href="http://openjdk.java.net/jeps/165" target="_blank" rel="external">More about JEP 165</a><br><a name="dtls"></a></p><h3 id="12-Datagram-Transport-Layer-Security-DTLS"><a href="#12-Datagram-Transport-Layer-Security-DTLS" class="headerlink" title="12. Datagram Transport Layer Security (DTLS)"></a>12. Datagram Transport Layer Security (DTLS)</h3><p>Adding DTLS support, a secure way to communicate using datagram protocols such as UDP.</p><p><a href="http://openjdk.java.net/jeps/219" target="_blank" rel="external">More about JEP 219</a><br><a name="javadoc"></a></p><h3 id="13-HTML5-Javadoc"><a href="#13-HTML5-Javadoc" class="headerlink" title="13. HTML5 Javadoc"></a>13. HTML5 Javadoc</h3><p>Bringing Javadoc up to speed with the HTML standard: Generating modern HTML5 documentation.</p><p><a href="http://openjdk.java.net/jeps/224" target="_blank" rel="external">More about JEP 224</a></p><h2 id="Fixes-Cleanup"><a href="#Fixes-Cleanup" class="headerlink" title="Fixes / Cleanup:"></a><strong>Fixes / Cleanup:</strong></h2><p><a name="elideimport"></a></p><h3 id="14-Elide-Deprecation-Warnings-on-Import-Statements"><a href="#14-Elide-Deprecation-Warnings-on-Import-Statements" class="headerlink" title="14. Elide Deprecation Warnings on Import Statements"></a>14. Elide Deprecation Warnings on Import Statements</h3><p><a href="http://openjdk.java.net/jeps/211" target="_blank" rel="external">More about JEP 211</a><br><a name="doclint"></a></p><h3 id="15-Resolve-Lint-and-Doclint-Warnings"><a href="#15-Resolve-Lint-and-Doclint-Warnings" class="headerlink" title="15. Resolve Lint and Doclint Warnings"></a>15. Resolve Lint and Doclint Warnings</h3><p><a href="http://openjdk.java.net/jeps/212" target="_blank" rel="external">More about JEP 212</a><br><a name="millingcoin"></a></p><h3 id="16-Milling-Project-Coin"><a href="#16-Milling-Project-Coin" class="headerlink" title="16. Milling Project Coin"></a>16. Milling Project Coin</h3><p><a href="http://openjdk.java.net/jeps/213" target="_blank" rel="external">More about JEP 213</a><br><a name="removegc"></a></p><h3 id="17-Remove-GC-Combinations-Deprecated-in-JDK-8"><a href="#17-Remove-GC-Combinations-Deprecated-in-JDK-8" class="headerlink" title="17. Remove GC Combinations Deprecated in JDK 8"></a>17. Remove GC Combinations Deprecated in JDK 8</h3><p><a href="http://openjdk.java.net/jeps/214" target="_blank" rel="external">More about JEP 214</a><br><a name="processimport"></a></p><h3 id="18-Process-Import-Statements-Correctly"><a href="#18-Process-Import-Statements-Correctly" class="headerlink" title="18. Process Import Statements Correctly"></a>18. Process Import Statements Correctly</h3><p><a href="http://openjdk.java.net/jeps/216" target="_blank" rel="external">More about JEP 216</a><br><a name="newfeatures"></a></p><h2 id="19-Bonus-Where-do-new-features-come-from"><a href="#19-Bonus-Where-do-new-features-come-from" class="headerlink" title="19. Bonus: Where do new features come from?"></a>19. Bonus: Where do new features come from?</h2><p>JEPs and JSRs don’t usually pop out of nowhere, here’s the structure that holds it all together:</p><p><strong>Groups</strong> – Individuals and organisations with a mutual interest around a broad subject or a specific body of code. Some examples are Security, Networking, Swing, and HotSpot.</p><p><strong>Projects</strong> – Efforts to produce a body of code, documentation or other effort. Must be sponsored by at least one group. Recent examples are Project Lambda, Project Jigsaw, and Project Sumatra.</p><p><strong>JDK Enhancement Proposal</strong> (<a href="http://openjdk.java.net/jeps/0" target="_blank" rel="external">JEP</a>) – Allows promoting a new specification informally before or in parallel to the JCP, when further exploration is needed. Accepted JEPs become a part of the JDK roadmap and assigned a version number.</p><p><strong>Java Specification Request</strong> (<a href="https://jcp.org/en/jsr/all" target="_blank" rel="external">JSR</a>) – The actual specification of the feature happens in this stage, can be either coming through Groups/Projects, JEPs or from individual JCP (Java Community Process) members. An umbrella JSR is usually opened for each Java version, this has yet to happen with Java 9. Individual members of the community can also propose new Java specification requests.</p><p>JEP和JSR并不是无中生有, 下面就介绍一下Java发展的生态环境:</p><p>小组 - 对特定技术内容, 比如安全, 网络, Swing, HotSpot, 有共同兴趣的组织和个人</p><p>项目 - 编写代码, 文档以及其他工作, 至少由一个小组赞助和支持, 比如最近的Lambda计划, Jigsaw计划和Sumatra计划.</p><p>JDK改进提案(JEP) - 每当需要有新的尝试的时候, JEP可以在JCP(Java Community Process)之前或者同时提出非正式的规范(specification). 被正是认可的JEP正式写进JDK的发展路线图并分配版本号.</p><p>Java规范提案(JSR) - 新特性的规范出现在这一个阶段, 可以来自于小组 / 项目, JEP, JCP成员或者Java社区(community)成员的提案. 每个Java版本都由相应的JSR支持, Java 9暂时还没有.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;footer&gt;&lt;strong&gt;Java 9 的发布在历经多次跳票之后，终于正式发布。从这个版本开始，Java 将每半年发布一个版本。 本文翻译自Java 9 Ultimate Feature List, 让我们看看这次发布我们将拥有哪些高级特性。&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;http://openjdk.java.net/projects/jdk9/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;openjdk.java.net&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Translation" scheme="https://blog.rabears.com/categories/Translation/"/>
    
      <category term="Java" scheme="https://blog.rabears.com/categories/Translation/Java/"/>
    
    
      <category term="Java 9" scheme="https://blog.rabears.com/tags/Java-9/"/>
    
      <category term="新特性" scheme="https://blog.rabears.com/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="Java" scheme="https://blog.rabears.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>关于Facebook 的 React 专利许可证</title>
    <link href="https://blog.rabears.com/2017/09/20/react-revocable-license/"/>
    <id>https://blog.rabears.com/2017/09/20/react-revocable-license/</id>
    <published>2017-09-20T02:33:22.000Z</published>
    <updated>2017-09-21T06:48:54.090Z</updated>
    
    <content type="html"><![CDATA[<p>随着Apache、百度、Wordpress都在和Facebook的React.js以及其专利许可证划清界限，似乎大家又在讨论Facebook的这个BSD+PATENT的许可证问题了。这让我想起了之前在Medium读过的一篇文章——《<a href="https://medium.com/@dwalsh.sdlr/react-facebook-and-the-revokable-patent-license-why-its-a-paper-25c40c50b562" target="_blank" rel="external">React, Facebook, and the Revocable Patent License, Why It’s a Paper</a>》，我觉得那篇文章写的不错，而且还是一个会编程的律师写的，所以有必要把这篇文章传播到中文社区这边来。注意，我不会全部翻译，我只是用我的语言来负责搬运内容和观点，我只想通过这篇文章让大家了解一下这个世界以及专利相关的知识，这样可以避免你看到某乎的“怎么看待XXX”这类的问题时人云亦云，能有自己的独立思考和自我判断。;-)<br><a href="https://github.com/facebook/react/blob/master/PATENTS" target="_blank" rel="external">React Additional Grant of Patent Rights Version 2</a><br><a id="more"></a></p><p>这篇文章的作者叫Dennis Walsh，他自称是亚历桑那和加利福尼亚州的律师，主要针对版权法和专利诉论的法律领域。但是这个律师不一样，他更很喜欢商业和软件多一些。现在他用React/GraphQL/Elixir在写一个汽车代理销售相关的软件，而且已经发布到第2版了。</p><p>首先，作者表明，专利法经常被人误解，因为其实充满了各种晦涩难懂的法律术语，所以，作者用个例子来讲述专利的一个原则 —— <strong>专利并不是授于让你制造或开发的权利，而是授予你可以排他的权利。（</strong>事实上似乎也是这样，申请专利很多时候都不是为了制作相关的产品，而是为了防止别人使用类似的技术制作相关的产品）</p><p>如果有公司X为铅笔申请了专利，而另一家公司Y为把用于铅笔的橡皮擦申请了专利。那么，公司X可以阻止公司Y来生产铅笔，而对带橡皮擦的铅笔没办法，但是公司Y的专利可以让公司X不能生产带有橡皮擦的铅笔。</p><p>所以，公司Y的橡皮擦专利又被广泛地叫作“<a href="https://definitions.uslegal.com/b/blocking-patent/" target="_blank" rel="external">Blocking Patent</a>”。公司Y不能说他发明了铅笔，因为这是公司X的专利，但是，他们可以让公司X无法对铅笔做出某些改进。</p><p>于是，因为这种 Blocking Patent 存在，对于开源的公司是不利的，因为根据上面的那个例子来说，开源公司就是公司X，他们做了一个基础的软件，而公司Y在上面做了些改进，并注册成了专利，从而导致开源的公司X无法对它基础开源软件作出被公司Y专利阻止的改进，开源的公司X希望能够自由地使用公司Y的橡皮擦专利，因为毕竟是它发明了铅笔并放弃了铅笔的专利。</p><p>于是就出来了“专利反击条款”（<a href="https://en.wikipedia.org/wiki/Software_patents_and_free_software#Patent_retaliation" target="_blank" rel="external">Patent Retaliation Clauses</a>）。一般来说有两种专利条款，一种是弱条款，一种是强条款。</p><p>Weak Patent Retaliation Clauses – 这种条款声明，如果许可证持有者用某个专利来打击许可证颁布者，那么专利就视为终止。用人话来表达就是，公司X做了一个开源铅笔，而公司Y注册了橡皮檫专利。此时，公司X做了一支带像皮擦的铅笔，而公司Y马上对公司X提起专利侵权诉讼。那么，公司Y就失去了对底层铅笔的专利控制。（正如前面所说的，公司Y的橡皮擦专利因为在起诉公司X的开源铅笔，而失去了对开源铅笔的专利排他权利）</p><p>Strong Patent Retailiation Clauses – 这种条款声明比“弱条款”要的更多。具体来说就是，任何专利声明终结许可证，而不管这个专利有没有和你基础的软件有关系。用人话来说就是，公司Y使用他们的热气球专利来起诉公司X，那么公司Y就失去了他们对铅笔的专利限制。</p><p>我个人理解起来，这两种条款看上去是防御性质的。</p><p>Facebook的React的Patent License如下：</p><blockquote><p>The license granted hereunder will terminate, automatically and without notice,if you (or any of your subsidiaries, corporate affiliates or agents) initiatedirectly or indirectly, or take a direct financial interest in, any Patent Assertion: (i) against Facebook or any of its subsidiaries or corporateaffiliates, (ii) against any party if such Patent Assertion arises in whole orin part from any software, technology, product or service of Facebook or any ofits subsidiaries or corporate affiliates, or (iii) against any party relating to the Software. Notwithstanding the foregoing, if Facebook or any of itssubsidiaries or corporate affiliates files a lawsuit alleging patentinfringement against you in the first instance, and you respond by filing apatent infringement counterclaim in that lawsuit against that party that isunrelated to the Software, the license granted hereunder will not terminateunder section (i) of this paragraph due to such counterclaim.</p></blockquote><p>这些条款中和基础软件没有任何关系，所以，<strong>这个条款是“强专利反击条款”</strong>。</p><p>在后面，本文的作者又解解释了，为什么React的“强专利反击条款”就跟没有似的。他在文中针对一些歇斯底里的言论，如：“Facebook不用害怕专利诉讼了，而且他可以随时偷袭你家的专利仓库”，也作出了一些解释来分析这个事。</p><p>Contractural Liability – 意思是说，专利方面的东西只会影响专利上的事，而不会影响和专利无关的事，React底层协议是BSD-3许可证还是会被保留。换句话说，React的“强专利反击条款”只生效于专利层面，而不会对非常专利的软件使用产生问题，如果和专利无关，React还是走BSD-3的许可协议。</p><p>Copyright Liability – 这个和Contractural Liablitity 一样。作者说，如果有人有特别的案例或是有说服力的论据来说明Facebook的这个条款会作用于非专利的地方，那么，请告诉他。</p><p>Patent Liability – 专利的责任和损害是两件事，非专业人士总是会把其搞混。</p><p>第一个问题是Liability， 要搞清这个事，得搞清“Patent’s Claims”，而不是这个技术的技术规格说明，技术规格说明和权力主张是两码事。作者说，现在的很多专利都是一些想法，很多投机份子随便一拍脑袋就发明出一个想法，然后就去注册专利了。但是可以被用来法律执行的只有“Patent’s Claims”（专利的权利主张），而不是那些想法。这些权利主张相当相当的晦涩难读，而且是会故意被模糊掉的，因为，当你清楚的定义了你的发明是什么，那么，就可以清楚的定义出来什么不是你的发明。比如：一个铅笔专利权利主张里说，“这一个用石墨和木头组合起来的写字工具”，那么，只要我不用木头和石墨来做组合，而是用塑料来做组合，那么我就不是专利侵权。所以，一般来说，专利主张是会更为通用一些，比如，“这是一个用于涂画表面的装置，其包括：与涂画端相连的握持端”。作者这里给了一个<a href="https://www.google.com/patents/US8046721" target="_blank" rel="external">苹果公司的滑动解锁专利</a>的示例。可以感受一下产品规格说明和专利权利主张完全是两码事。</p><p>专利这些事，在法律界里是非常非常困难作出评估的。所以，这个社会每年都会给律师们几十亿美金来一遍又一遍地回答这些问题，而且律师还经常回答错了。而对于美国的法律，对于专利诉讼会有一个叫<a href="https://en.wikipedia.org/wiki/Markman_hearing" target="_blank" rel="external">Markman hearing的审前听证会</a>（马克曼听证会），自从1996年美国最高法的“<a href="https://en.wikipedia.org/wiki/Markman_v._Westview_Instruments,_Inc." target="_blank" rel="external">马克曼诉威斯幽仪器公司案</a>”这个听证会就变成了一个惯例，美国联邦法院用这个听证会来向决定专利权利主张的解释，而且，上诉法院还经常性的推翻审判法院的裁决。（对于美国法律来说，一般是法官认证法律，陪审团认定事实，然而，对于专利而言，1996年的那个案件认为专利术语是一个需要法官决定的法律问题，而不是陪审团决定的事实问题。关于马克曼听证会的事，可以参看本文未尾的附录）</p><p>所以，要决定Facebook的专利责任，我们需要评估Facebook的专利及其权利主张，而不是技术规格说明。具体来说，要明确Facebook对于React这个底层技术的专利权利主张是什么？但是作者搜了一下，发现什么也没有找到。也就是说，对于USPTO（美国专利商标局）或法院来说，他们没办法对Facebook的这样没有为React申请专利的方式来执行任何和专利的诉讼，也就是说，Facebook的这个React License的条款，美国政府是无法在法律上支持的。</p><p>第二个问题是专利损害。就算是Facebook可以评估出来一个合法可执行的专利来保护React，对于专利损害也是很有问题的。作者说他到目前还没有发现一个开源软件被专利侵权的事，就算有这样的案例，也不会是这里说的这个事。作者觉得在这个事上操作起来就是一个笑话。</p><p>另外，作者认为，React 专利许可证这个事就是个纸老虎。因为，一方面，这个专利不像电信通讯里的那些专利，你拿不掉。作者认为要从你的代码中把React去掉虽然难，但是也不是什么很难的事，另外，要打这样的专利官司，一般来说，在美国至少要花100-200万美金的费用才能发起诉讼，而要胜诉则需要需要200多万到2000万美金的费用，你觉得你要花多钱才能把React从你的代码库中剔除？肯定比这钱少。</p><p>作者还认为，Facebook玩这个事虽然出发点不错，但是感觉并不聪明，从目前的情况看下来，就像他想咬你一口，但却没有牙。</p><p>后面，作者还说了一下，转成别的框架会不会有问题？比如：你用Preact/Vue或是你自研的东西？作者说，未必，如果Facebook真的为React注册了专利，比如：React里的组件技术、虚拟DOM渲染技术等等。那么，你用Preact/Vue或是带这样技术的自研的框架，那么，从你使用的第一天就在侵犯Facebook的专利权了。然而，使用React反而不会有这么大的风险，因为Facebook让你免费的用React。作者说，用别的框架的法律风险比用其它替代品的风险更高。</p><p>后面，作者也更新了一篇文章 《<a href="https://medium.com/@dwalsh.sdlr/using-graphql-why-facebook-now-owns-you-3182751028c9" target="_blank" rel="external">Using GraphQL? Why Facebook Now Owns You</a>》，意思是，用React可能还好，但是用GraphQL就有问题了。因为找到了GraphQL的专利—— <a href="https://patents.google.com/patent/US9646028" target="_blank" rel="external">“Graph Query Logic”</a>。</p><p>后来我查了一下，我发现，React也有个相关的专利—— “<a href="https://patents.google.com/patent/US9003278" target="_blank" rel="external">Efficient event delegation in browser scripts</a> ”，看上去和虚拟DOM渲染有关。Holy Shit!</p><p>好了，用还是不用React我也不知道，总之，这个世界比较复杂，我只是想借这篇文章来学习一下法律上的相关东西，欢迎听到大家的观点。</p><p>最后，请允许我调侃一下来结束本文——“不用担心React的许可证问题，因为前端不是一年半就用新的框架重写一次么？”哈哈。</p><h4 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h4><h5 id="马克曼听证会-–-Markman-Hearing"><a href="#马克曼听证会-–-Markman-Hearing" class="headerlink" title="马克曼听证会 – Markman Hearing"></a>马克曼听证会 – Markman Hearing</h5><p>马克曼听证会的一些背景知识，下面的文字来源于《<a href="http://www.sipo.gov.cn/sipo2013/mtjj/2013/201303/t20130320_788543.html" target="_blank" rel="external">“马克曼听证”制度的由来及启示</a>》</p><p>与美国专利诉讼的悠长历史相比，1996年才经美国最高法院确立的“马克曼听证”（Markman Hearing，也称为Claim Construction，即权利要求书的解释）无疑是一项年轻的制度。但由于几乎所有的专利侵权诉讼中都会遇到涉案专利权利要求书的解释这一核心问题，且因“马克曼听证”结果往往清楚地预示了案件结果，经“马克曼听证”获得有利结论的一方一旦据此向法庭提起不审即判的动议，专利侵权诉讼往往可就此快速了结，因此该制度的确立成为美国专利诉讼历史上的一件大事。</p><p>“马克曼听证”制度的由来</p><p>“马克曼听证”制度确立之前，在专利侵权诉讼中的权利要求书解释，通常交由陪审团在对案件事实进行裁决时一并做出，且并不会在诉讼文件上单独就陪审团这一问题的判断进行记录。1991年，马克曼（Markman）先生因认为其拥有的专利号为RE33054的“干洗衣物贮存及追踪控制装置”专利权被Westview公司所侵犯，遂向宾夕法尼亚州东区联邦地方法院提起了专利侵权诉讼。</p><p>该专利是用扫描的方式，将客户的衣物编号扫描后输入电脑中做分类标示，并在衣物干洗过程中追踪衣物位置，干洗完成后自动将衣物放回客户固定的存贮位置。被告的产品则是同时运用扫描器和电脑两种方式，将客户干洗衣物的资料存入电脑并显示费用、日期等相关信息。本案陪审团的裁决认为被告装置构成对原告专利权利的侵犯，但该地方法院认为系争专利与被告装置在功能实施上并不一致，遂推翻陪审团的裁决，判决被告不构成侵权。</p><p>马克曼不服，于1995年向联邦上诉法院提起上诉，但其上诉理由仅为联邦地方法院错误地解释了陪审团关于专利权利要求书解释中某个词语的涵义。联邦上诉法院在审理该案时，将案件的核心问题定为两个：一是原告对于请求项解释有无权利请求陪审团裁决;二是联邦地方法院是否正确地解释了“Inventory”一词。该院多数法官经审理后认为，权利要求书范围的解释与确定，属于法律问题而非事实问题，因而属于法院权限，而不应交由陪审团决定，且此前将此问题交由陪审团确定并不妥当。同时，由于认为原告专利与被告装置存在实质功能上的差异，联邦上诉法院亦不认为被告构成专利侵权。少数持不同意见的该院法官主要是质疑这一结论违反了美国第七宪法修正案（即所有根据美国法律进行的普通法诉讼，只要争议金额超过20美元，即有要求陪审团审判的权利）。</p><p>马克曼不服，向最高法院提出上诉。1996年4月23日，美国最高法院就马克曼诉Westview器械公司案（Markman v. Westview Instruments, Inc. 517 U.S. 370 （1996））做出终审裁决，裁决认定：权利要求书的解释是联邦地区法院法官应当处理的法律问题，而不是应当由陪审团来认定的事实问题，尽管在解释权利要求书的过程中可能会包含一些对于事实问题的解释，且这样做并不违反第七修正案赋予给陪审团的权利。这一裁决标志着“马克曼听证”制度的正式确立。</p><p>“马克曼听证”制度的不足</p><p>该案判决是美国专利诉讼史上的一个重大转折。“马克曼听证”成为法官专门用于解释专利权利要求的一个经常性听证程序，用以解决专利侵权诉讼的核心问题。由于该听证并非普遍适用，因此，十几年来，联邦民事诉讼规则并未正式对其有任何规定，而是给予法院绝对的自由裁量权。但是，何时可以进行“马克曼听证”?如何进行?是否有必要进行?类似问题在一定程度上困扰了审理专利侵权案件较多的法院。</p><p>2001年，加州北区联邦地区法院率先制定了供本法院使用的专利审判专属规则（Patent Local Rules），其中第四部分即为权利要求书的解释程序（Claim Construction Proceddings），对“马克曼听证”的时间、流程、限制及当事人的义务均进行了规定。此后，各州纷纷效仿。目前，乔治亚州北区联邦法院、得克萨斯州东区联邦法院、得克萨斯州南区联邦法院、宾夕法尼亚州西区联邦法院等都制订了书面的“马克曼听证”程序指南。近年来，不断有新的案例在解释与细化着“马克曼听证”，如2006年的Wilson Sporting Goods Co.诉Hillerich &amp; Bradsby Co.案，2005年的Phillips诉AWH Corp.案，2008年的Howmedica Osteonics Corp.诉Wright Medical Technology, Inc.案，这些司法实践大大拓展与丰富了“马克曼听证”使用的实体和程序规则，使之日渐成为美国专利诉讼中一个复杂、完备的司法程序。以至于竟然有人开发了模拟“马克曼听证”程序，只要你愿意，可以下载并训练，以熟悉和确保有真正的权利要求书解释时不会出现不利于自己的问题。</p><p>但是，该听证带来的问题也逐渐受到重视。有人质疑说该程序导致专利诉讼费用增加，因为“马克曼听证”通常会单独进行，且程序复杂，因此导致当事人花费大量的时间与精力，更为重要的是，由于40%至60%的联邦地区法院案件会在联邦巡回上诉法院被推翻，因此，花费巨大的“马克曼听证”似乎价值有限。同时，权利要求书的解释要求是不多不少，忠实于技术发明思想与发明事实，但由于地区法院分散，法官的相关技术知识不十分专业，将权利要求书解释这样的问题交给他们，难免会带来一些无法克服的问题。</p><p>“马克曼听证”制度的启示</p><p>我国民事诉讼中并无陪审团制度，案件的事实问题与法律问题均由法官审理与确定。在专利侵权诉讼中，对于案件中涉及到的技术问题可以通过专家鉴定等方式解决，但并不因此免除法官审理案件的义务，即法律问题的判断归于法官，事实的法律属性判断仍然归于法官。同时，权利要求书的解释在我国的专利侵权诉讼中并不是一个单独的程序，而是合并在案件审理过程中。因此，仅就我国的司法审判而言，“马克曼听证”制度并无直接的借鉴意义。</p><p>但是，对于那些已经走出和正在走出国门的企业来说，了解与掌握这一重要的专利诉讼程序却是极其重要的。通领科技集团的积极尝试充分证明了这一点，而且随着这一程序的不断成熟，美国国际贸易法院（ITC）也开始在审理时适用“马克曼听证”制度。所以，知道“马克曼听证”意味着什么，确保所提交的用于解释权利要求的文件确实充分，学会利用“马克曼听证”，无论是对于破解美国的专利诉讼威胁，还是为未来准备有效的法律武器，无疑都非常重要。（知识产权报　作者　魏玮）</p><blockquote><p>本文转载自 <a href="https://coolshell.cn/articles/18140.html" target="_blank" rel="external">CoolShell</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着Apache、百度、Wordpress都在和Facebook的React.js以及其专利许可证划清界限，似乎大家又在讨论Facebook的这个BSD+PATENT的许可证问题了。这让我想起了之前在Medium读过的一篇文章——《&lt;a href=&quot;https://medium.com/@dwalsh.sdlr/react-facebook-and-the-revokable-patent-license-why-its-a-paper-25c40c50b562&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React, Facebook, and the Revocable Patent License, Why It’s a Paper&lt;/a&gt;》，我觉得那篇文章写的不错，而且还是一个会编程的律师写的，所以有必要把这篇文章传播到中文社区这边来。注意，我不会全部翻译，我只是用我的语言来负责搬运内容和观点，我只想通过这篇文章让大家了解一下这个世界以及专利相关的知识，这样可以避免你看到某乎的“怎么看待XXX”这类的问题时人云亦云，能有自己的独立思考和自我判断。;-)&lt;br&gt;&lt;a href=&quot;https://github.com/facebook/react/blob/master/PATENTS&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React Additional Grant of Patent Rights Version 2&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://blog.rabears.com/categories/Tech/"/>
    
      <category term="ReactJs" scheme="https://blog.rabears.com/categories/Tech/ReactJs/"/>
    
    
      <category term="react" scheme="https://blog.rabears.com/tags/react/"/>
    
      <category term="license" scheme="https://blog.rabears.com/tags/license/"/>
    
      <category term="facebook" scheme="https://blog.rabears.com/tags/facebook/"/>
    
  </entry>
  
</feed>
